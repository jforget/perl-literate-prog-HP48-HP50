fr: Programmation littéraire pour HP-48 et HP-50
en: Literate programming for HP-48 and HP-50
ex1: code
ex2: dir
ex3: dir
ex-cycle: dir
---
- section: 0
  'fr,en': Introduction
- fr: |
    Ceci est un texte auto-descriptif
    présentant le format que j'ai choisi pour faire
    de la programmation littéraire pour 
    les calculatrices HP fonctionnant en RPL.
- en: |
    This is a self-describing text showing the
    format I chose to use literate programming for
    RPL-using HP calculators.
- fr: |
    Si vous lisez une alternance de français et d'anglais
    avec quelques symboles curieux, vous lisez le bon fichier.
    Si vous lisez un texte bien présenté et entièrement en
    français sur votre navigateur Internet ou si vous lisez du HTML, 
    vous lisez un fichier annexe. Sa lecture peut vous éclairer sur
    la programmation littéraire, mais il n'est plus auto-descriptif.

    Il est préférable de lire en parallèle le texte d'origine (français
    + anglais avec les symboles spéciaux) et le texte HTML généré
    pour mieux se rendre compte du fonctionnement du système.
- en: |
    If you are reading alternating paragraphs in French and in English,
    with a few special formulas spread between, you are reading the proper
    self-describing file. If you are reading a properly rendered file in
    your web browser, or some HTML source, you are reading a secondary
    file, which may give you some information, but which cannot be
    considered as self-describing.

    It is better to read in parallel the source file (French + English
    with some special symbols) and the generated HTML file, so the
    operation of the system is easier to understand.
- fr: |
    La programmation littéraire a été popularisée, peut-être même
    inventée, par Donald Knuth. À partir d'un fichier source, 
    <var>toto</var><tt>.web</tt> contenant du code, des commentaires
    et quelques directives d'édition, il génère un fichier 
    <var>toto</var><tt>.tex</tt> pour la documentation et un fichier
    source Pascal <var>toto</var><tt>.p</tt> pour le programme à proprement
    parler. Une variante appelée CWEB part d'un fichier
    <var>toto</var><tt>.cweb</tt> pour obtenir un fichier de documentation
    <var>toto</var><tt>.tex</tt>  et un fichier programme en C
    <var>toto</var><tt>.c</tt> 

    Et comme le fichier à l'usage des humains est distinct
    du fichier à l'usage du compilateur, rien n'oblige à ce qu'ils
    présentent le code dans le même ordre. Donc, par exemple, le fichier 
    <var>toto</var><tt>.tex</tt> commence par donner une idée générale
    de l'algorithme, puis il définit la structure de données principale,
    puis le détail de l'algorithme, puis les initialisations et enfin
    le traitement des erreurs. À l'inverse, pour les besoins du compilateur,
    le fichier <var>toto</var><tt>.p</tt> doit commencer par la description
    des structures de données, puis la déclaration des variables globales
    et le corps de l'algorithme est mélangé avec le traitement des cas limites
    et la gestion des erreurs.
    Comme le fichier source <var>toto</var><tt>.web</tt>
    et le fichier <var>toto</var><tt>.tex</tt>
    ont la même structure, Knuth a appelé <tt>weave</tt>
    («&nbsp;tisser&nbsp;») le programme permettant
    de passer de <var>toto</var><tt>.web</tt> à <var>toto</var><tt>.tex</tt>.
    À l'inverse, <var>toto</var><tt>.p</tt> et <var>toto</var><tt>.web</tt>
    ont des structures nettement différentes, donc le programme permettant de
    passer de l'un à l'autre s'appelle <tt>tangle</tt> («&nbsp;emmêler&nbsp;»).
- en: |
    Literay programming was popularised, maybe even created,
    by Donald Knuth. Starting with a source file 
    <var>toto</var><tt>.web</tt> which contains code, comments and
    a few editing commands, he generates a 
    <var>toto</var><tt>.tex</tt> documentation file and a
    <var>toto</var><tt>.p</tt> Pascal source file for the program.
    A variant named CWEB starts with a
    <var>toto</var><tt>.cweb</tt> file to produce a 
    <var>toto</var><tt>.tex</tt>  documentation file and a
    <var>toto</var><tt>.c</tt> C programme file.

    Since the human-readable file is different from the compiler-readable
    file, they can present the code in a different order. So, for
    example, the <var>foo</var><tt>.tex</tt> file can first give a
    general orverview of the algorithm, then define the main data
    structure, show the details of the algorithm and end with
    intialisation and error processing. On the other hand, the
    <var>toto</var><tt>.p</tt> file must begin with the definition of
    data structures and the declaration of global variables and the
    algorithm's main functions include the processing of border cases  
    and of errors. The source file 
    <var>toto</var><tt>.web</tt> has the same structure as 
    <var>toto</var><tt>.tex</tt>, so the programme generating
    the T<sub>E</sub>X file is called <tt>weave</tt>. On the other
    hand, the structure of <var>toto</var><tt>.p</tt> is very different,
    so the programme generating the Pascal file is called <tt>tangle</tt>.
- fr: |
    Ma version diffère sur plusieurs points.
    <ul>
    <li>Le fichier documentation généré n'est pas du T<sub>E</sub>X,
    mais du HTML.</li>
    <li>WEB et CWEB génèrent un seul fichier de documentation, mon
    système permet de générer plusieurs fichiers dans des langues
    différentes à partir d'un fichier <tt>.hpweb</tt> multilingue.</li>
    <li>WEB génère du Pascal, CWEB génère du C, mon système génère du
    RPL pour les calculatrices HP.</li>
    <li>C'est le même programme qui tisse les fichiers de documentation
    et qui emmêle les fichiers de code.</li>
    <li>CWEB a un mécanisme assez malcommode pour générer plusieurs fichiers
    de code&nbsp;: les <i lang='en'>change files</i> (comme le résultat de <tt>diff</tt>
    et son traitement ultérieur par <tt>patch</tt>, mais en moins bien). Et cela permet de générer seulement
    des fichiers de code similaires, se distinguant par quelques variantes éparses.
    Mon système permet de générer des fichiers de code qui peuvent être des variantes
    d'un fichier de base, ou bien des fichiers complémentaires, partageant très peu de code.</li>
    </ul>
- en: |
    My version differs on several points.
    <ul>
    <li>The human-readable file is not T<sub>E</sub>X  but HTML</li>
    <li>WEB and CWEB generate only one documentation file, my
    programme uses a multilingual <tt>.hpweb</tt> file to generate
    several documentation files.</li>
    <li>WEB generates Pascal, CWEB generates C or C++ and my programme
    generates User-RPL for HP calculators.</li>
    <li>The same programme weaves the documentation files and tangles
    the code files.</li>
    <li>CWEB has a cumbersome mechanism to produce several code files: change files
    (a bit like <tt>diff</tt>'s output, processed by <tt>patch</tt>, but less efficient).
    My system allows you to produce easily several code files, either variants of a basic
    file, or independant dissimilar files.</li>
    </ul>
- section: 0
  fr: Principe
  en: Principle
- fr: |
    Le texte source est écrit dans un fichier
    <a href='http://www.yaml.org/'>YAML</a> contenant deux
    variables. La première, très brève, se contente d'énumérer
    les langues utilisées en donnant à cette occasion le titre
    du fichier HTML généré. Elle liste également les noms des fichiers 
    qui contiendront le code.
- en: |
    The source text comes from a <a href='http://www.yaml.org/'>YAML</a>
    file. This YAML file contains two variables. The first one,
    much shorter than the second one, lists all the languages
    used and for each of them gives the title of the HTML file.
    It lists also the filenames where code will be stored.
- fr: |
    La seconde variable est une liste de fragments. Chaque fragment
    peut être&nbsp;:

    <ul>
      <li>un fragment section</li>
      <li>du texte</li>
      <li>du code</li>
    </ul>

    Attention, il faut bien distinguer les «&nbsp;fragments sections&nbsp;»
    des «&nbsp;sections&nbsp;». Un fragment section se termine lorsque
    commence un autre fragment, que ce soit du texte, du code, voire un
    autre fragment section, tandis qu'une section regroupe tous les fragments
    à partir d'un fragment section (inclus) jusqu'au fragment section suivant
    (exclus, car faisant partie de la section suivante).
- en: |
    The second variable is a list of chunks. Each chunk can be:

    <ul>
      <li>a section fragment</li>
      <li>some text</li>
      <li>some code</li>
    </ul>

    Note that a "section fragment" is not the same as a section.
    A section fragment ends when the next fragment, text or code, begins.
    A section is the collection of all fragments from a first section
    fragment (included) to the next section fragment (excluded, because
    it belongs to the next section).
- fr: |
    Le tissage consiste à construire un fichier HTML pour chaque
    code langue. Le programme passe en revue tous les fragments
    et tient compte des fragments sections, des fragments codes
    indépendamment de la langue et des fragments textes associés 
    à la langue en cours de traitement.

    Pour chaque fragment, le programme effectue un léger traitement
    de formattage. Ainsi, les fragments sections donnent lieu
    à une balise <tt>&lt;h</tt><var>n</var><tt>&gt;</tt> et à
    une balise <tt>&lt;a name='</tt><var>xxx</var><tt>'&gt;</tt>.
    Les fragments de code sont encadrés par des balises <tt>&lt;pre&gt;</tt>.

    En outre, dans les fragments de texte et de code, on repère les références
    (balisées par «&nbsp;@&nbsp;» ou par «&nbsp;|&nbsp;») pour établir
    un lien <tt>&lt;a href='#</tt><var>xxx</var><tt>'&gt;</tt> vers
    d'autres sections.
- en: |
    Weaving consists in building an HTML file for each language code.
    The program scans all fragments, keeping the sections fragments
    and code fragment irrespective of the language code and the
    text fragments tagged with the current language code.

    Each fragment is slightly reformatted. A section fragment
    generates a <tt>&lt;h</tt><var>n</var><tt>&gt;</tt> tag and a
    <tt>&lt;a name='</tt><var>xxx</var><tt>'&gt;</tt> tag.
    The code fragments are sandwiched between <tt>&lt;pre&gt;</tt> tags.

    In addition, in text fragments and code fragments, the program
    looks for references tagged by "@" or "|" and generates
    links <tt>&lt;a href='#</tt><var>xxx</var><tt>'&gt;</tt> to other
    sections.
- fr: |
    L'emmêlement se passe ainsi pour un fichier de code donné&nbsp;:
    le programme commence par répertorier toutes les sections 
    appelées dans ce fichier. Il passe également en revue tous les
    fragments de code de toutes
    les sections pour en extraire les références consistant à inclure
    une section dans une autre. Après s'être assuré qu'il n'y a pas
    de dépendance circulaire et après avoir déterminé dans quel ordre
    il faut générer les sections, le programme effectue ces insertions
    et écrit le fichier de code final.
- en: |
    For a given code file, tangling consists in the following actions.
    The program starts by listing all the sections assigned to the
    file. It also scans all code fragments from all sections to extract the insertion-type
    references. It checks there is no cycle in these references 
    and determines in which order the sections will be generated
    by inserting other sections. Then, the program writes the
    code sections into the final code file.
- section: 0
  fr: Détails
  en: Details
- section: 0
  fr: Jeu de caractères
  en: Characters set
  level: 3
- fr: |
    Le fichier est écrit en UTF-8 pour être lu par YAML. Mais la machine
    cible utilise un codage spécifique assez proche de l'ISO-8859.
    Pour les caractères utilisés par les HP-48 et HP-50 qui ne figurent
    pas dans le jeu de caractère ISO-8859-1, il faudra utiliser une
    séquence de caractères introduite par un <i lang='en'>backslash</i>.
    Par exemple, les lignes&nbsp;:
- en: |
    The file is written in UTF-8 to be readable by YAML. But the
    target machine uses a specific encoding similar to ISO-8859.
    For the characters belonging to the HP-48/HP-50 character set,
    but not the ISO-8859-1 character set, you will use backslash sequences.
    So, the following lines:
- code: |
    \\<) \\x- \\.V \\v/ \\.S \\GS \\|> \\pi \\.d \\<= \\>= \\=/ \\Ga \\-> \\<- \\|v \\|^
    \\Gg \\Gd \\Ge \\Gn \\Gh \\Gl \\Gr \\Gs \\Gt \\Gw
    \\GD \\PI \\GW \\[] \\oo
- fr: |
    donneront lieu à&nbsp;:
- en: |
    will result in:
- code: |
    \<) \x- \.V \v/\.S \GS \|> \pi \.d \<= \>= \=/ \Ga \-> \<- \|v\|^
    \Gg \Gd \Ge \Gn \Gh \Gl \Gr \Gs \Gt \Gw
    \GD \PI \GW \[] \oo
- fr: |
    Notons que certains caractères qui figurent dans le jeu de caractères
    ISO-8859-1 ont eux aussi une séquence introduite par <i lang='en'>backslash</i>
    alors qu'il n'en ont pas réellement besoin.
- en: |
    Note that some characters which do belong to the ISO-8859-1 character set
    have a backslash sequence, although they would not need it.
- code: |
    \\<< \\^o \\Gm \\>> \\.x \\O/ \\Gb \\:-
    «   °   µ   »   ×   Ø   ß   ÷
- fr: |
    Et si vous avez besoin de faire apparaître une telle séquence
    sans la remplacer par le caractère spécial, il suffit d'insérer
    un <i lang='en'>backslash</i> avant cette séquence, pour désactiver
    l'interprétation du <i lang='en'>backslash</i>. C'est vrai également
    pour désactiver l'interprétation du «&nbsp;@&nbsp;» et du «&nbsp;|&nbsp;»
    dans les cas où ils pourraient être compris à tort comme des liens vers d'autres
    sections.
- en: |
    And if you need to display such a sequence without replacing it
    by the special character, you just have to insert a backslash before
    the sequence, to deactivate the interpretation of the backslash.
    The same procedure applies to the cases when "@" or "|" would be
    wrongly understood as links to other sections.
- fr: |
    Remarque&nbsp;: les germanophones remarqueront que le jeu de caractères
    des calculatrices HP confond allègrement le béta grec et le s-tsett allemand.
    Désolé, ce n'est pas moi qui ai pris cette option.
- en: |
    The German-speaking people will note that the character set used by HP
    calculators does not make any difference between the Greek beta and the
    German s-tsett. I am sorry, but it is not my fault.
- section: 0
  fr: Syntaxe YAML
  en: YAML Syntax
  level: 3
- fr: |
    Pour les besoins de la syntaxe YAML, pour chaque fragment,
    la première ligne du contenu doit commencer par 4&nbsp;espaces
    et les lignes suivantes par 4&nbsp;espaces ou plus.
- en: |
    For the YAML syntax, the first line of each chunk
    must begin with 4 spaces and the next lines must begin
    with 4 or more spaces.
- fr: |
    Lorsqu'il y a besoin d'un code langue, il est possible de spécifier
    plusieurs codes langues séparés par des virgules. Cela permet de mettre
    en commun le texte associé, s'il ne contient aucun élément traduisible 
    ou si la traduction est identique à l'original. Par exemple.
- en: |
    When a language code is required, it is allowed to enter several
    codes joined with a comma. This allows to use the same text for all
    given languages, if this text contains no translatable element,
    or if the translation is identical to the original sentence.For example
- code: |
    'fr,en': Introduction
- fr: |
     est remplacé par&nbsp;:
- en: |
     is replaced by:
- code: |
    fr: Introduction
    en: Introduction
- fr: |
    Dans un fragment de texte ou un fragment de code, la première
    ligne fixe l'indentation minimale du fragment et toutes les lignes
    qui suivent doivent avoir une indentation supérieure ou égale.
    Pour passer outre cette limitation, vous pouvez spécifier une
    première ligne composée en tout et pour tout d'un point précédé
    de quatre espaces et vous avez toute latitude pour l'indentation
    de la deuxième ligne. La première ligne sera supprimée lors de 
    l'emmêlement et du tissage.

    Pour les fragments de code, cela vous permet d'avoir une indentation
    cohérente d'un fragment à l'autre. Pour les fragments de texte, je
    ne vois pas dans quelles circonstances cela pourrait servir, mais
    on ne sait jamais.

    Et si vous voulez quand même une ligne constituée d'un point et
    rien d'autre, mettez cette ligne en double. Le premier exemplaire
    de la ligne sera supprimé, le second sera conservé.
- en: |
    In a text fragment or a code fragment, the first line specify the
    minimum indentation of the lines of the fragment and all subsequent
    lines must have the same indentation or a greater one. To circumvent
    this limitation, you can write a first line consisting of a sigle
    period, following four spaces. And then, you can choose any indentation
    for the second line and the other. During weaving and tangling, the
    first line with a single period will be removed.

    For code fragments, this feature allows you to keep a consistent
    indentation from a code fragment to the next. For text fragments, 
    I do not know in which case it could be useful, but you
    never know.

    And if you really want a line consisting of a single period, 
    just write two such lines. The first will be removed, but the
    second one will be kept.
- fr: |
    Rappel&nbsp;: YAML n'aime pas les tabulations. Pensez donc à 
    utiliser si nécessaire <tt>untabify</tt> sous Emacs ou <tt>expand</tt>
    sous shell.
- en: |
    Remember that YAML does not like tabulations. So, use <tt>untabify</tt>
    under Emacs or <tt>expand</tt> under shell when necessary.

- section: 0
  fr: Préparation
  en: Preparation
- fr: |
    La préparation consiste à répertorier quelles langues utiliser
    pour la documentation et quels fichiers générer pour le code.
    Cela se fait en examinant la première variable saisie dans le fichier
    YAML. Cette variable est une table de hachage, interprétée ainsi&nbsp;:

    Dans le couple clé-valeur, si la valeur est <tt>dir</tt> ou <tt>code</tt>,
    la clé est le nom d'un fichier qui contiendra du code. Sinon, la clé
    est un code langue et la valeur est le titre du fichier HTML généré.
- en: |
    The preparation consists in determining which languages will be used
    for the documentation and which files will contain code. This is specified
    in the first variable typed in the YAML file. This variable is a hashtable,
    which is interpreted in the following way.

    If the value of a key-value pair is <tt>dir</tt> or <tt>code</tt>, then
    the key is the filename for a file which will contain code. Else, the
    key is a language code and the value is the title of the generated HTML
    file.
- fr: |
    Si vous remontez au tout début du présent fichier <tt>.hpweb</tt>,
    vous pouvez constater qu'il y aura quatre fichiers de code&nbsp;: 
    <tt>ex1</tt>, <tt>ex2</tt>, <tt>ex3</tt> et <tt>ex-cycle</tt>. De plus, la documentation
    est écrite en français (code <tt>fr</tt>, titre «&nbsp;Programmation littéraire
    pour HP-48 et HP-50&nbsp;») et en anglais (code langue <tt>en</tt>, titre
    <i lang='en'>Literate programming for HP-48 and HP-50</i>).
- en: |
    If you go back to the beginning of the present <tt>desctiption.hpweb</tt>
    file, you can see that three code files will be generated: <tt>ex1</tt>,
    <tt>ex2</tt>, <tt>ex3</tt> and <tt>ex-cycle</tt>. The documentation is written in
    English (language code <tt>en</tt>, title "Literate programming for HP-48 and HP-50")
    and in French (language code <tt>fr</tt>, title <i lang='fr'>Programmation littéraire
    pour HP-48 et HP-50</i>).
- fr: |
    Il n'y a pas de contrôle vis-à-vis de la table ISO-639
    des codes langues. Vous pouvez saisir n'importe quel code constitué de caractères
    alphanumériques, ils seront interprétés comme indiqué ci-dessus. Ainsi, si 
    le fichier <tt>ams-soviet.hpweb</tt> commence par&nbsp;:
- en: |
    There is no check with the ISO-639 table for language
    codes. You can enter any alphanumeric string for the various codes. Thus, if
    the <tt>ams-soviet.hpweb</tt> file starts with:
- code: |
    'Side_Globe,Don_Kay': Small_Fred,Mare_Tail
    Skip_Spin: code
    Flap_Lid: dir
    Light_Bulb: Top_Trough,Rum_Tub,Straight_Key
- fr: |
    il y aura deux fichiers de code&nbsp;:
    <tt>Skip_Spin</tt> et <tt>Flap_Lid</tt>,
    et trois fichiers de documentation
    <tt>ams-soviet.Side_Globe.html</tt> intitulé «&nbsp;Small_Fred,Mare_Tail&nbsp;»
    <tt>ams-soviet.Don_Kay.html</tt> intitulé «&nbsp;Small_Fred,Mare_Tail&nbsp;»
    et <tt>ams-soviet.Light_Bulb.html</tt> intitulé «&nbsp;Top_Trough,Rum_Tub,Straight_Key&nbsp;»
- en: |
    there will be two code files:
    <tt>Skip_Spin</tt> et <tt>Flap_Lid</tt>,
    and three documentation files:
    <tt>ams-soviet.Side_Globe.html</tt> titled "Small_Fred,Mare_Tail"
    <tt>ams-soviet.Don_Kay.html</tt> titled "Small_Fred,Mare_Tail"
    et <tt>ams-soviet.Light_Bulb.html</tt> titled "Top_Trough,Rum_Tub,Straight_Key".


- section: 0
  fr: Tissage
  en: Weaving
- fr: |
    Le tissage est présenté ci-dessous pour un code langue donné,
    alors qu'il concerne tous les codes langues en parallèle.

    Le nom du fichier en sortie est le nom du fichier en entrée,
    moins l'extension <tt>.hpweb</tt>, plus un point, le code
    langue et l'extension <tt>.html</tt>. Par exemple, pour le
    français, le fichier <tt>description.htweb</tt> donnera
    le fichier en sortie <tt>description.fr.html</tt>
- en: |
    Weaving is explained hereafter for one language code, although
    the real program processes all language codes in parallel.

    The name of the output file is the name of the input file,
    minus the <tt>.hpweb</tt> extension, plus a dot, the language
    code and the extension <tt>.html</tt>. For example, for
    the English language, the
    input file <tt>description.htweb</tt> will produce the output
    file <tt>description.en.html</tt>.
- fr: |
    Le titre spécifié dans la première variable du fichier YAML
    permet d'avoir le contenu de l'élément <tt>&lt;title&gt;</tt>
    et de l'élément <tt>&lt;h1&gt;</tt> du fichier HTML.
- en: |
    The title specified in the first variable of the YAML
    file gives the contents of the <tt>&lt;title&gt;</tt>
    and the <tt>&lt;h1&gt;</tt> elements in the HTML file.
- fr: |
    Pour le tissage, le programme extrait dans l'ordre tous les fragments sections,
    tous les textes dépendant du code langue utilisé et tous les
    fragments de code.
- en: |
    When weaving, the program extracts all section fragments, all texts
    which belongs to the current language code, all code fragments.
- fr: |
    Chaque fragment section génère une balise <tt>&lt;h2&gt;</tt>
    et une balise <tt>&lt;a name='...'&gt;</tt>, le nom étant
    donné par l'attribut <tt>section</tt> de la section. Le contenu
    est donné par le nom de la section et le texte associé à la langue.
- en: |
    Each section fragment generates a <tt>&lt;h2&gt;</tt> tag and a
    <tt>&lt;a name='...'&gt;</tt> tag, the name of which is
    given by the <tt>section</tt> attribute. The contents is the
    section name and the text associated to the language.
- fr: |
    Si un fragment section contient une clé <tt>level</tt>, alors le 
    programme utilise la valeur <var>n</var> correspondante pour générer
    une balise <tt>&lt;h</tt><var>n</var><tt>&gt;</tt> à la place
    de <tt>&lt;h2&gt;</tt>.
- en: |
    If a section fragment includes a <tt>level</tt> key, the program
    uses the corresponding value <var>n</var> to generate a
    <tt>&lt;h</tt><var>n</var><tt>&gt;</tt> tag instead of
    the <tt>&lt;h2&gt;</tt> tag.
- fr: |
    Si la valeur correspondant à la clé <tt>section</tt> est <tt>0</tt>,
    il s'agit d'une section anonyme. Dans ce cas, la balise
    <tt>&lt;a name='...'&gt;</tt> sera générée avec le titre de la
    section.
- en: |
    If the value corresponding to the <tt>section</tt> key is <tt>0</tt>,
    this is an anonymous section. The 
    <tt>&lt;a name='...'&gt;</tt> tag will be generated using the
    section's title.
- fr: |
    Pour les textes, le balisage par défaut est les balises <tt>&lt;p&gt;</tt>.
    Chaque paragraphe (fragment de texte ou portion de fragment de texte
    délimitée par des lignes vides) sera encadré par 
    <tt>&lt;p&gt;</tt> et <tt>&lt;/p&gt;</tt>, sauf si une balise existe
    déjà au début et à la fin. Et si par hasard, vous 
    ne voulez pas de balise, il vous suffit d'ajouter
    un commentaire HTML <tt>&lt;!-- blabla --&gt;</tt>.
- en: |
    Default tagging for texts is <tt>&lt;p&gt;</tt>, so
    each paragraph (text fragment or text fragment portion
    delimited by empty lines) will be surrounded by
    <tt>&lt;p&gt;</tt> and <tt>&lt;/p&gt;</tt>, except if another tag exists
    both at the beginning and at the end of the paragraph.
    And if you do not want any tag, just add 
    an HTML comment <tt>&lt;!-- blahblah --&gt;</tt>.
- fr: |
    Les fragments de type code sont tous repris
    dans le fichier HTML généré. De plus, pour les
    fragments de type <tt>GROB</tt>, le programme génère un
    fichier <tt>.png</tt> représentant le bitmap associé
    (développement ultérieur, ce n'est pas encore prêt).
    Le fichier n'est pas appelé automatiquement dans le HTML
    généré, il faut l'appeler «&nbsp;manuellement&nbsp;» avec
    une balise <tt>&lt;img&gt;</tt> dans un fragment texte.
- en: |
    All code fragments are used when generating
    the HTML file.  
    In addition, for <tt>GROB</tt> fragments, the program generates
    a <tt>.png</tt> file containing the bitmap (to be developped
    later, it is not ready yet).
    This file is not automatically linked to in the generated
    HTML file, you must include a <tt>&lt;img&gt;</tt> tag in
    a text fragment to show it.
- fr: |
    Dans tous les cas, fragment section, texte et code, le tissage recherche
    les séquences introduites par un <i lang='en'>backslash</i> pour
    les remplacer par le caractère associé (en fait, la séquence
    <tt>&amp;#</tt><var>nnn</var><tt>;</tt>). Par exemple,
    la séquence <tt>\\pi</tt> sera remplacée par <tt>&amp;#960;</tt>, c'est-à-dire \pi.
    En même temps, les noms de section encadrés par des <tt>@</tt> ou des
    <tt>|</tt> sont transformés en liens hypertextes vers la section du
    même nom (cela dit, il n'y a pas de contrôle, le lien peut pointer
    vers le néant s'il n'existe aucune section de ce nom).
    Et dans le cas des fragments codes, les <tt>&lt;&gt;&amp;</tt> sont
    remplacés par la séquence HTML correspondante. Ce n'est pas fait
    pour les fragments sections et les textes, car ceux-ci contiennent déjà du marquage
    HTML et on considère que les  <tt>&lt;&gt;&amp;</tt> y sont déjà sous
    la forme <tt>&amp;lt;&amp;gt;&amp;amp;</tt>.
- en: |
    In all cases, section fragments, text and code, weaving looks for substrings
    starting with a backslash to substitute them with the associated
    character (or actually, the corresponding
    <tt>&amp;#</tt><var>nnn</var><tt>;</tt> sequence). For example,
    <tt>\\pi</tt> will be replaced by <tt>&amp;#960;</tt>, that is, \pi.
    At the same time, the section names sandwiched between two <tt>@</tt>'s
    or two <tt>|</tt>'s are changed into an hyperlink to the section
    with the corresponding name (yet, there is no check; if the name 
    defines no section, the link will be dangling).
    And for code fragments, the <tt>&lt;&gt;&amp;</tt> are escaped.
    This is not done for section fragments and texts, because they already include
    HTML tags, and we consider that all <tt>&lt;&gt;&amp;</tt> are already coded
    as <tt>&amp;lt;&amp;gt;&amp;amp;</tt>.

- section: 0
  fr: Emmêlement
  en: Tangling
- fr: |
    L'emmêlement permet de générer un ou plusieurs fichiers
    téléchargeables sur les machines HP-48 ou HP-50.
    Il peut y avoir plusieurs raisons pour générer
    plusieurs fichiers&nbsp;:

    <ul>
      <li>un fichier contient les fonctions de base et les autres fichiers les fonctions étendues,</li>
      <li>les fichiers contiennent des chaînes de caractères dans des langues différentes
      pour les invites et les messages,</li>
      <li>les fichiers concernent des machines cibles différentes, par exemple une HP-48
      avec un affichage 64x131 et une HP-50 avec un affichage 80x131,</li>
      <li>un fichier contient les routines utilitaires sous formes de variables globales
      dans le répertoire de la HP, pour faciliter la mise au point, tandis qu'un autre
      fichier stocke toutes ces routines utilitaires dans des variables locales
      des programmes fournis.</li>
    </ul>
- en: |
    Tangling results in the generating of one or several
    files loadable on HP-48's and HP-50's. There can
    be several reasons to generate several files&nbsp;:

    <ul>
    <li>one file contains the basic functions and the others contain the extensions,</li>
    <li>each file contains prompt strings and message strings in a different language,</li>
    <li>the files apply to different target machines, for example one file for HP-48's
    with a 64x131 screen and another file for HP-50's with a 80x131 screen,</li>
    <li>one file stores all routines into global variables, to facilitage
    development, while the other stores these routines as local variables
    inside the main programs.</li>
    </ul>
- section: 0
  fr: Extraction des liens
  en: Extracting the links
  level: 3

- fr: |
    La première étape consiste à recenser tous les fragments de code
    qui s'appliquent au fichier de code en cours de constitution et
    à identifier les liens (appels et insertions) qui s'y trouvent.
    À cette occasion, le programme bâtit un graphe des appels et un
    graphe des insertions.
- en: |
    The first step consists in collating all code fragments which are
    involved in building the current code file, and extracting all the
    links (calls and inserts) which exist in these fragments.
    During this step, the program builds a graph for the insert links 
    and another graph for the call links.
- fr: |
    La sélection du code se fait à deux niveaux&nbsp;: section et fragment.
    Si la section est une section anonyme (<tt>section:&nbsp;0</tt>),
    elle ne sera sélectionnée dans aucun fichier de code.
    Une section nommée sera sélectionnée pour un fichier si le fragment
    section contient un attribut avec le nom du fichier comme clé
    et avec un nombre supérieur ou égal à 1 comme valeur.
    S'il n'y a pas un tel attribut, la section pourra être quand
    même utilisée, si elle est incluse dans une section sélectionnée
    (ou incluse dans une section elle-même incluse dans... et ainsi de 
    suite, récursivement).
- en: |
    Selecting code is done on two levels: section and fragment.
    An anonymous section  (<tt>section:&nbsp;0</tt>) is never selected
    in any code file. A named section will be selected if the
    section fragment includes a attribute whose key is the 
    code file name and whose value is a number, 1 or greater.
    If no such attribute exists, the section might still be selected
    if it is included in an already selected section (or included
    in a section included in... and so on, recursively).
- fr: |
    La sélection sur les fragments est assez semblable. Si un fragment
    comporte un attribut avec le nom du fichier de code en clé, alors
    le fragment de code sera inclus dans le fichier de code.
    La seule différence par rapport aux sections est que si un fragment
    ne comporte aucun attribut dont la clé est un nom de fichier de code,
    alors il sera appelé dans tous les fichiers.
- en: |
    The selection on fragments is rather similar to the selection on sections.
    If a fragment contains an attribute pair whose key is a code file name,
    the fragment will be selected in this file. The main difference with section
    selection is that if the code fragment does not contain any attribute 
    whose key is a code file name, then this fragment will be used by all 
    code files.
- fr: |
    Voici un exemple (à lire dans le fichier <tt>.hpweb</tt> pour mieux comprendre)
- en: |
    Here is an example (best understood if you read the <tt>.hpweb</tt> file)
- section: CVTCAR
  level: 4
  ex1: 1
  ex2: 1
  ex3: 1
- code: |
    « 
- ex1: 1
  ex-cycle: 1
  code: |
    |SUBSG| \-> SUBSG
- code: |
    .
      «
        "<-" 142 @SUBSG@
        "->" 141 @SUBSG@
        "<=" 137 @SUBSG@
        ">=" 138 @SUBSG@
        "=/" 139 @SUBSG@
        IF DUP "%%HP" POS
        THEN
          DUP 10 CHR POS 1 +
          OVER SIZE
          SUB
        END
      »
    »
- section: SUBSG
  level: 4
  ex2: 2
  ex3: 2
  ex-cycle: 1
- code: |
    « "\" ROT + SWAP CHR
- ex1: 1
  ex3: 1
  ex-cycle: 1
  code: |
    .
      \-> ch av ap
- ex2: 1
  code: |
    'ap' STO 'av' STO 'ch' STO
- code: |
    .
      « WHILE ch av POS
        REPEAT
          ch 1 OVER av POS 1 - SUB
          ap +
          ch DUP av POS av SIZE +
          OVER SIZE SUB +
          'ch' STO
        END ch
      »
    »
- ex-cycle: 1
  code: |
    "cycle" |CVTCAR|
- fr: |
    La section @CVTCAR@ sera appelée dans les trois fichiers <tt>ex1</tt>, <tt>ex2</tt> et
    <tt>ex3</tt>, tandis que la section @SUBSG@ ne sera, apparemment, sélectionnée
    que dans <tt>ex2</tt> et <tt>ex3</tt>. Pour la section @CVTCAR@, le fichier <tt>ex2</tt>
    utilisera un stockage dans des variables globales pour des besoins
    de débugage, tandis que les fichiers <tt>ex1</tt> et <tt>ex3</tt> stockeront tout dans des variables
    locales. De plus, le fichier <tt>ex1</tt> inclura le code de @SUBSG@ et le stockera dans
    une autre variable locale.
- en: |
    The @CVTCAR@ section will be selected in both <tt>ex1</tt>, <tt>ex2</tt> and <tt>ex3</tt>
    files. On the other hand, it seems that the @SUBSG@ section will be selected
    only in <tt>ex2</tt> and <tt>ex3</tt>. For the @CVTCAR@ section, the <tt>ex2</tt> file
    will store values into global variables, for debugging purposes. The
    <tt>ex1</tt> and <tt>ex3</tt> files will store them into local variables. In addition,
    the <tt>ex1</tt> file will include the @SUBSG@ code and store it into another local variable.
- fr: |
    Quant au fichier <tt>ex-cycle</tt>, il appelle au premier niveau la section @SUBSG@,
    qui inclut la section @CVTCAR@, qui inclut à son tour @SUBSG@, ce qui constitue un problème certain.
- en: |
    As for the <tt>ex-cycle</tt> file, il selects the @SUBSG@ section, which includes the
    @CVTCAR@ section, which in turn includes @SUBSG@, which causes some kind of problem.
- section: 0
  fr: Tri des sections de code
  en: Sorting the code sections
  level: 3
- fr: |
    La deuxième étape a deux buts&nbsp;:

    <ol>
    <li>
    établir un tri topologique des sections en fonction des insertions,
    pour savoir quelles sections il faut traiter en premier, lesquelles
    il faut traiter en second et ainsi de suite.
    </li>
    <li>
    détecter les cycles dans le graphe des insertions.
    </li>
    </ol>

- en: |
    The second step achieves two purposes:

    <li>
    topologically sort the sections according to the insertion
    links, to determine in which order they have to be generated.
    </li>
    <li>
    detect any cycles in the insertions graph.
    </li>
    </ol>

- fr: |
    Le tri topologique consiste à passer en revue tous les liens d'insertion
    et à comparer le niveau hiérarchique de la section englobante et celui
    de la section insérée. Le niveau de la section englobante doit être supérieur,
    strictement, à celui de la section insérée. Si ce n'est pas le cas, le niveau
    de la section englobante est mis à jour avec le niveau hiérarchique de la section
    insérée plus 1.

- en: |
    The topological sort consists in scanning all insertion links and comparing
    the hierachical level of the calling section with the level of the inserted
    section. The level of the calling section must be greater than (and not equal to)
    the level of the inserted section. If this is not the case, the calling section's
    level is updated, using the inserted section's level plus one.

- fr: |
    Le mécanisme s'arrête dans deux cas. Tout d'abord, si on a effectué une passe
    sur tous les liens d'insertion sans qu'il y ait eu besoin de mettre à jour 
    un niveau hiérarchique. Le tri est alors achevé. Ou alors, si on détecte qu'une
    section a un niveau hiérarchique supérieur au nombre de sections existantes.
    Dans ce cas, cela signifie qu'il existe un cycle dans les liens d'insertion.
    Et le fichier n'est pas généré.

- en: |
    The algorithm stops in two ways. First, it stops if during a scan of all insertion
    links, no hierarchical level has been updated. The sort is finished. Or second,
    if we notice that a section has a hierarchical level greater than the total
    number of sections. That means that there is a cycle in the insertion links and
    that the sort must be interrupted. And we do not generate the code file.

- fr: |
    Remarque&nbsp;: dans la version actuelle, on tient compte de toutes les sections
    et de tous les liens d'insertion déclarés pour le fichier, même si parmi
    ces sections, il en existe qui constituent du «&nbsp;code mort&nbsp;» (sections
    qui ne sont pas reliées au fichier à générer par un lien d'insertion). Cela peut
    créer des rejets abusifs. Cela sera corrigé dans une version ultérieure.

- en: |
    NB: in the current version, all sections and all insertion links are checked,
    even if some sections are "dead code", that is, they are not linked to the
    generated file with insertion links. That can produce a rejection of the generated
    file. This will be corrected in a next release.

- fr: |
    Il y a d'autres cas d'erreur, comme une section que l'on a oublié d'inclure,
    ou bien que l'on a inclue plusieurs fois alors qu'il ne fallait pas le faire,
    ou encore une section globale inclue en tant que section locale.
    Ces cas de figure ne sont pas traitée automatiquement par le programme,
    c'est au programmeur de s'en rendre compte en jetant un coup d'&oelig;il
    sur le graphe des appels et des insertions.

- en: |
    There are other error conditions, such as a section which has not been included
    or a section which has been included several times instead of just once,
    or a global section which has been included into another section, just as
    a local one. These error cases are not detected by the program. The programmer
    has to detect them, mainly by examining the insertion and call graph.

- section: 0
  fr: Génération des sections de code
  en: Generating the code sections
  level: 3

- fr: |
    Les sections sont générées dans l'ordre de la hiérarchie croissante.
    Dans chaque fragment de code, on extrait les liens, aussi bien les
    liens d'insertion (balisés par <tt>|</tt>) que les liens d'appel
    (balisés par <tt>@</tt>). Un lien d'insertion est remplacé par
    le code de la section associée, tout simplement. Pour les liens
    d'appel, c'est un peu plus compliqué. Si la section appelée est
    une section globale, alors le code généré est réduit au nom de
    la section. En revanche, s'il s'agit d'une section locale,
    il faut la faire suivre de <tt>EVAL</tt>.

    Une section peut être globale dans un premier fichier de code
    et locale dans un autre. C'est pour cela que l'instruction <tt>EVAL</tt>
    n'est pas codée dans le source, mais générée lors de la construction
    du code.

- en: |
    Sections are generated in hierarchical order. In each code fragment,
    the program extracts both types of links, insertions links tagged
    by <tt>|</tt> and call links tagged by <tt>@</tt>. The processing
    of insertion links is simple: they are replaced by the code
    of the inserted section. The processing of call links is a bit more
    complicated: if the section is a global one (file-level section),
    the link is replaced by the section name and that's all. If the
    section is a local one, it has to be followed by <tt>EVAL</tt>.

    A section can be global in a first code file and local in a second
    one. This is the reason why <tt>EVAL</tt> is not written in the
    source file, but generated on demand when building the code files.

- section: 0
  fr: Écriture des fichiers de code
  en: Writing the code files
  level: 3

- fr: |
    Pour un fichier de type <tt>code</tt>, toutes les sections globales
    sont écrites, dans l'ordre de leur attribut <tt>rang</tt> (celui
    qui a été spécifié par le nom du fichier de code). Pour un fichier 
    de type <tt>dir</tt>, on commence par le mot-clé <tt>DIR</tt>, 
    puis pour chaque section globale, on écrit le nom puis le code.
    Et on termine par <tt>END</tt>. Cela sert à créer un répertoire
    entier dans la machine cible.

- en: |
    For a <tt>code</tt> type file, all global sections are written
    ordered by their <tt>rang</tt> attribute (which was specified
    by the filename). For a <tt>dir</tt> type file, the program
    writes first the keyword <tt>DIR</tt>. Then, for all global
    sections, it writes the section name and the section code.
    At last, it ends the code file with the keyword <tt>END</tt>.
    Such a file allows the creation of a whole directory in 
    the target calculator.

- section: 0
  fr: Licence
  en: License
- fr: |
    Ce code est diffusé sous les mêmes termes que Perl, la licence GPL
    et la licence artistique.
- en: |
    This code is published under the same terms as Perl: GPL and Artistic License.
