#!/usr/bin/perl
#
# Génération de la documentation HTML et du fichier à transférer

use strict;
use warnings;
use YAML;
use Data::Dumper;

my $racine = $ARGV[0];

my %transco1 = ( # méta-caractères
       '@', '@', '\\', '\\', '£', '£',
       # flèches
       '<-', '2190', '|^', '2191', '->', '2192', '|v', '2193', 
       # comparaisons
       '=/', '2260', '<=', '2264', '>=', '2265',
       # grec minuscule
       'pi', '3c0', 'Ga', '3b1', 'Gg', '3b3', 'Gd', '3b4', 'Ge', '3b5', 'Gn', '3b7',
       'Gh', '3b8', 'Gl', '3bb', 'Gr', '3c1', 'Gs', '3c3', 'Gt', '3c4', 'Gw', '3c9',
       # autres symboles (à revoir : v- |> )
       '<)', '2221', 'x-', 'x-', '.V', '2207', 'v/', '221a', '.S', '222b', 'GS', '2211',
       '|>', '25b6', '.d', '2202', 'GD', '2206', 'PI', '220f', 'GW', '3a9', '[]', '220e',
       'oo', '221e', 
    );
$transco1{'x-'} = 'x&#772;';
my %transco2 = ( '<', '&lt;', '>', '&gt;', '&', '&amp;' );
my $re1 = join '|', map { quotemeta $_ } keys %transco1;
for (values %transco1) {
  $_ = sprintf "&#%d;", hex($_)
    if /^[0-9a-f]+$/i;
}

my %textes;
my %codes;

my ($h, $l) = YAML::LoadFile("$racine.hpweb");
#print Data::Dumper::Dumper($h, $l);

for (keys %$h) {
  if ($h->{$_} eq 'code') {
    $codes{$_} = 1;
  }
  else {
    my $nom = "$racine.$_.html";
    open my $f, '>:encoding(utf8)', $nom
      or die "Ouverture $nom $!";
    $textes{$_}{name} = $nom;
    $textes{$_}{fh} = $f;
    print $f <<"EOF";
<html>
<head>
<meta http-equiv='content-type' content='Text/html; charset=utf-8' />
<title>$h->{$_}</title>
</head>
<body>
<a href='#$h->{$_}'>$h->{$_}</a>
EOF
  }
}

# séparer les codes langues
for my $fragment (@$l) {
  for my $cle (keys %$fragment) {
    if ($cle =~ /,/) {
      for my $cle1 (split ',', $cle) {
	$fragment->{$cle1} = $fragment->{$cle};
      }
    }
  }
}

#print Data::Dumper::Dumper($h, $l);

for my $fragment (@$l) {
  if (defined $fragment->{section}) {
    my $section = $fragment->{section};
    for (keys %textes) {
      my $f = $textes{$_}{fh};
      my $titre = transcrit($fragment->{$_} || '', 0);
      if ($section && $titre) {
        print $f "<br /><a href='#$section'><tt>$section</tt> - $titre</a>\n";
      }
      elsif ($titre) {
        my $lien = $titre;
        $lien =~ s/[<>&']/_/g;
        print $f "<br /><a href='#$lien'>$titre</a>\n";
      }
      elsif ($section) {
        print $f "<br /><a href='#$section'><tt>$section</tt></a>\n";
      }
    }
  }
}

for (keys %textes) {
  my $f = $textes{$_}{fh};
  my $titre = $h->{$_};
  print $f "<hr /><h1><a name='$titre'>$titre</a></h1>\n";
}

for my $fragment (@$l) {
  if (defined $fragment->{section}) {
    my $section = $fragment->{section};
    my $niveau  = $fragment->{level} || 2;
    #print "$section\n";
    for (keys %textes) {
      my $f = $textes{$_}{fh};
      my $titre = transcrit($fragment->{$_} || '', 0);
      if ($section && $titre) {
        print $f "<h$niveau><a name='$section'><tt>$section</tt> - $titre</a></h$niveau>\n";
      }
      elsif ($titre) {
        my $lien = $titre;
        $lien =~ s/[<>&']/_/g;
        print $f "<h$niveau><a name='$lien'>$titre</a></h$niveau>\n";
      }
      elsif ($section) {
        print $f "<h$niveau><a name='$section'><tt>$section</tt></a></h$niveau>\n";
      }
    }
    next;
  }
  elsif ($fragment->{code}) {
    my $code = transcrit($fragment->{code}, 1);

    for my $lg (keys %textes) {
      my $f = $textes{$lg}{fh};
      print $f "<pre>\n$code</pre>\n";
    }

    next;
  }
  else {
    # Fragment de texte, indexé par le code langue
    for my $lg (keys %$fragment) {
      for my $paragraphe (split /\n\n+/, transcrit($fragment->{$lg}, 0)) {
	#print "--$paragraphe--\n";
	if ($paragraphe !~ /\A\<.*\>\z/s && $paragraphe !~ /\A\<.*\>\Z/s) {
	  $paragraphe = "<p>\n$paragraphe</p>\n";
	}
	my $f = $textes{$lg}{fh};
	print $f $paragraphe, "\n";
      }
    }
  }
}

for (keys %textes) {
  my $f = $textes{$_}{fh};
  print $f "</body>\n</html>\n";
  close $f
    or die "fermeture $textes{$_}{name} $!";
}

for (keys %codes) {
  open my $f, '>', $_
    or die "Ouverture $_ $!";
  print $f <<'EOF';
%%HP: T(3)A(R)F(,);
EOF

  # reste à faire

  close $codes{$_}
    or die "fermeture $codes{$_}{name} $!";
}

exit(0);

sub transcrit {
  # $texte : le texte à transcrire, $transc_html : faut-il transcrire les <>& en HTML ou bien sont-ils déjà transcrits ?
  my ($texte, $transc_html) = @_;

  my @morceau = split /\\($re1) # capture des séquences préfixées par backslash
		    | @(\w+)@   # capture des appels à une étiquette
		    | £(\w+)£   # capture des insertions
		    | ([<>&])   # capture des caractères spéciaux HTML
		    /x, $texte;

  for (my $i = 1; $i < $#morceau; $i +=5) {
    $morceau[$i    ] ||= ''; 
    $morceau[$i + 1] ||= ''; 
    $morceau[$i + 2] ||= ''; 
    $morceau[$i + 3] ||= ''; 
    my $etiq_call = $morceau[$i + 1];
    my $etiq_ins  = $morceau[$i + 2];
    if ($morceau[$i]) {
      $morceau[$i] = $transco1{$morceau[$i]};
    }
    elsif ($etiq_call) {
      $morceau[$i + 1] = "<a href='#$etiq_call'>$etiq_call</a>";
    }
    elsif ($etiq_ins) {
      $morceau[$i + 2] = "<a href='#$etiq_ins'>$etiq_ins</a>";
    }
    elsif ($transc_html) {
      $morceau[$i + 3] = $transco2{$morceau[$i + 3]};
    }
  }
  return join '', @morceau;
}
